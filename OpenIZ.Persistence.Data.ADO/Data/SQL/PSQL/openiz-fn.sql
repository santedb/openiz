-- RETURNS WHETHER THE USER ACCOUNT IS LOCKED
CREATE OR REPLACE FUNCTION IS_USR_LOCK(
	USR_NAME_IN IN TEXT
) RETURNS BOOLEAN AS 
$$
BEGIN
	RETURN (SELECT (LOCKED > CURRENT_TIMESTAMP) FROM SEC_USR_TBL WHERE USR_NAME = USR_NAME_IN);
END
$$ LANGUAGE PLPGSQL;


-- AUTHENTICATES THE USER IF APPLICABLE
CREATE OR REPLACE FUNCTION AUTH_USR (
	USR_NAME_IN IN TEXT,
	PASSWD_IN IN TEXT,
	MAX_FAIL_LOGIN_IN IN INT
) RETURNS SEC_USR_TBL AS $$
DECLARE
	USR_TPL SEC_USR_TBL;
BEGIN
	SELECT INTO USR_TPL * 
		FROM SEC_USR_TBL
		WHERE USR_NAME = USR_NAME_IN;

	IF (IS_USR_LOCK(USR_NAME_IN)) THEN
		UPDATE SEC_USR_TBL SET FAIL_LOGIN = FAIL_LOGIN + 1, LOCKED = CURRENT_TIMESTAMP + ((FAIL_LOGIN - MAX_FAIL_LOGIN_IN) * '30 SECONDS'::INTERVAL)
			WHERE USR_NAME = USR_NAME_IN;
		RETURN (
				null::UUID, 
				null::UUID, 
				'ERR:ACCOUNT LOCKED OUT'::CITEXT, 
				null::VARCHAR(256), 
				false, 
				null::VARCHAR(128), 
				false, 
				false, 
				USR_TPL.LOCKED, 
				null::VARCHAR(128), 
				null::VARCHAR(128), 
				USR_TPL.FAIL_LOGIN, 
				null::TIMESTAMPTZ, 
				null::TIMESTAMPTZ, 
				null::UUID, 
				null::TIMESTAMPTZ, 
				null::UUID, 
				null::TIMESTAMPTZ, 
				null::UUID);
	ELSE
		
		-- LOCKOUT ACCOUNTS
		IF(USR_TPL.FAIL_LOGIN > MAX_FAIL_LOGIN_IN) THEN 
			UPDATE SEC_USR_TBL SET FAIL_LOGIN = FAIL_LOGIN + 1, LOCKED = CURRENT_TIMESTAMP + ((FAIL_LOGIN - MAX_FAIL_LOGIN_IN) * '30 SECONDS'::INTERVAL)
				WHERE USR_NAME = USR_NAME_IN;
			RETURN (
				null::UUID, 
				null::UUID, 
				'ERR:ACCOUNT LOCKED OUT'::CITEXT, 
				null::VARCHAR(256), 
				false, 
				null::VARCHAR(128), 
				false, 
				false, 
				USR_TPL.LOCKED, 
				null::VARCHAR(128), 
				null::VARCHAR(128), 
				USR_TPL.FAIL_LOGIN, 
				null::TIMESTAMPTZ, 
				null::TIMESTAMPTZ, 
				null::UUID, 
				null::TIMESTAMPTZ, 
				null::UUID, 
				null::TIMESTAMPTZ, 
				null::UUID);
		ELSIF (USR_TPL.TFA_ENABLED) THEN
			UPDATE SEC_USR_TBL SET FAIL_LOGIN = USR_TPL.FAIL_LOGIN + 1 WHERE USR_NAME = USR_NAME_IN;
			RETURN (
				null::UUID, 
				null::UUID, 
				'ERR:USER REQUIRES TWO-FACTOR AUTHENTICATION'::CITEXT, 
				null::VARCHAR(256), 
				false, 
				null::VARCHAR(128), 
				false, 
				false, 
				USR_TPL.LOCKED, 
				null::VARCHAR(128), 
				null::VARCHAR(128), 
				USR_TPL.FAIL_LOGIN, 
				null::TIMESTAMPTZ, 
				null::TIMESTAMPTZ, 
				null::UUID, 
				null::TIMESTAMPTZ, 
				null::UUID, 
				null::TIMESTAMPTZ, 
				null::UUID);
		ELSIF (USR_TPL.PASSWD = PASSWD_IN) THEN
			UPDATE SEC_USR_TBL SET 
				FAIL_LOGIN = 0,
				LAST_LOGIN_UTC = CURRENT_TIMESTAMP,
				UPD_USR_ID = 'fadca076-3690-4a6e-af9e-f1cd68e8c7e8',
				UPD_UTC = CURRENT_TIMESTAMP
			WHERE USR_NAME = USR_NAME_IN;
			RETURN USR_TPL;
		ELSE
			UPDATE SEC_USR_TBL SET FAIL_LOGIN = USR_TPL.FAIL_LOGIN + 1 WHERE USR_NAME = USR_NAME_IN;
			RETURN (
				null::UUID, 
				null::UUID, 
				'ERR:INVALID USERNAME/PASSWORD'::CITEXT, 
				null::VARCHAR(256), 
				false, 
				null::VARCHAR(128), 
				false, 
				false, 
				USR_TPL.LOCKED, 
				null::VARCHAR(128), 
				null::VARCHAR(128), 
				USR_TPL.FAIL_LOGIN, 
				null::TIMESTAMPTZ, 
				null::TIMESTAMPTZ, 
				null::UUID, 
				null::TIMESTAMPTZ, 
				null::UUID, 
				null::TIMESTAMPTZ, 
				null::UUID);
		END IF;
	END IF;
	RETURN NULL;	

END	
$$ LANGUAGE PLPGSQL;

-- AUTHENTICATE AN APPICATION
CREATE OR REPLACE FUNCTION AUTH_APP (
	APP_PUB_ID_IN IN TEXT,
	APP_SCRT_IN IN TEXT
) RETURNS SETOF SEC_APP_TBL AS 
$$ 
BEGIN
	RETURN QUERY (SELECT * FROM SEC_APP_TBL WHERE APP_PUB_ID = APP_PUB_ID_IN AND APP_SCRT = APP_SCRT_IN LIMIT 1);
END
$$ LANGUAGE PLPGSQL;

-- AUTHENTICATE A DEVICE
CREATE OR REPLACE FUNCTION AUTH_DEV (
	DEV_PUB_ID_IN TEXT,
	DEV_SCRT_IN IN TEXT
) RETURNS SETOF SEC_DEV_TBL AS 
$$ 
BEGIN
	RETURN QUERY (SELECT * FROM SEC_DEV_TBL WHERE DEV_PUB_ID = DEV_PUB_ID_IN AND DEV_SCRT = DEV_SCRT_IN LIMIT 1);
END
$$ LANGUAGE PLPGSQL;

-- GET THE SCHEMA VERSION
CREATE OR REPLACE FUNCTION GET_SCH_VRSN() RETURNS VARCHAR(10) AS
$$
BEGIN
	RETURN '0.2.0.0';
END;
$$ LANGUAGE plpgsql;